#!/bin/bash
readonly XP_SHELL="/bin/bash"

# @Author Yamada, Yasuhiro
# @Filename xpanes

set -u
readonly XP_VERSION="3.2.0-beta"
trap 'rm -f "${XP_CACHE_HOME}"/__xpns_*$$' EXIT

## --------------------------------
# Error constants
## --------------------------------
# Undefined or General errors
readonly XP_EUNDEF=1

# Invalid option/argument
readonly XP_EINVAL=4

# Could not open tty.
readonly XP_ETTY=5

# Invalid layout.
readonly XP_ELAYOUT=6

# Syntax error of DLS
readonly XP_ESYNTAX=7

# Log related exit status is 2x.
## Could not create a directory.
readonly XP_ELOGDIR=20

## Could not directory to store logs is not writable.
readonly XP_ELOGWRITE=21

# User's intentional exit is 3x
## User exit the process intentionally by following warning message.
readonly XP_EINTENT=30

## All the panes are closed before processing due to user's options/command.
readonly XP_ENOPANE=31

# Necessary commands are not found
readonly XP_ENOCMD=127

# ===============

# XP_THIS_FILE_NAME is supposed to be "xpanes".
readonly XP_THIS_FILE_NAME="${0##*/}"
readonly XP_THIS_DIR="$(cd "$(dirname "${BASH_SOURCE[0]:-${(%):-%N}}")" && pwd)"
readonly XP_ABS_THIS_FILE_NAME="${XP_THIS_DIR}/${XP_THIS_FILE_NAME}"

# Prevent cache directory being created under root / directory in any case.
# This is quite rare case (but it can be happened).
readonly XP_USER_HOME="${HOME:-/etc}"

# Basically xpanes follows XDG Base Direcotry Specification.
# https://specifications.freedesktop.org/basedir-spec/basedir-spec-0.6.html
XDG_CACHE_HOME="${XDG_CACHE_HOME:-${XP_USER_HOME}/.cache}"
readonly XP_CACHE_HOME="${XDG_CACHE_HOME}/xpanes"

# This is supposed to be xpanes-12345(PID)
readonly XP_SESSION_NAME="${XP_THIS_FILE_NAME}-$$"
# Temporary window name is tmp-12345(PID)
readonly XP_TMP_WIN_NAME="tmp-$$"
readonly XP_EMPTY_STR="EMPTY"

readonly XP_SUPPORT_TMUX_VERSION_LOWER="1.8"

# This command might not be executed in bash. Use /bin/bash explicitly.
readonly XP_AWAIT_CMD=$'\n'${XP_SHELL}$' -c \'printf "%s " "Pane is dead: Press [Enter] to exit..." >&2 && read\''

# Check dependencies just in case.
# Even POSIX compliant commands are only used in this program.
# `xargs`, `sleep`, `mkfifo` are omitted because minimum functions can work without them.
readonly XP_DEPENDENCIES="${XP_DEPENDENCIES:-tmux grep sed tr od echo touch printf cat sort pwd cd mkfifo}"

## --------------------------------
# User customizable shell variables
## --------------------------------
TMUX_XPANES_EXEC=${TMUX_XPANES_EXEC:-tmux}
TMUX_XPANES_PANE_BORDER_FORMAT="${TMUX_XPANES_PANE_BORDER_FORMAT:-#[bg=green,fg=black] #T #[default]}"
TMUX_XPANES_PANE_BORDER_STATUS="${TMUX_XPANES_PANE_BORDER_STATUS:-bottom}"
XP_DEFAULT_TMUX_XPANES_LOG_FORMAT="[:ARG:].log.%Y-%m-%d_%H-%M-%S"
TMUX_XPANES_LOG_FORMAT="${TMUX_XPANES_LOG_FORMAT:-${XP_DEFAULT_TMUX_XPANES_LOG_FORMAT}}"
XP_DEFAULT_TMUX_XPANES_LOG_DIRECTORY="${XP_CACHE_HOME}/logs"
TMUX_XPANES_LOG_DIRECTORY="${TMUX_XPANES_LOG_DIRECTORY:-${XP_DEFAULT_TMUX_XPANES_LOG_DIRECTORY}}"

## --------------------------------
# Initialize Options
## --------------------------------
# options which work individually.
readonly XP_FLAG_OPTIONS="[hVdetxs]"
# options which need arguments.
readonly XP_ARG_OPTIONS="[ISclnf]"
readonly XP_DEFAULT_LAYOUT="tiled"
readonly XP_DEFAULT_REPSTR="{}"
readonly XP_DEFAULT_CMD_UTILITY="echo {} "
readonly XP_SSH_CMD_UTILITY="ssh -o StrictHostKeyChecking=no {} "
XP_OPTIONS=()
XP_ARGS=()
XP_STDIN=()
XP_IS_PIPE_MODE=0
XP_OPT_IS_SYNC=1
XP_OPT_DRY_RUN=0
XP_OPT_ATTACH=1
XP_OPT_LOG_STORE=0
XP_REPSTR=""
XP_SOCKET_PATH="${XP_SOCKET_PATH:-${XP_CACHE_HOME}/socket}"
XP_NO_OPT=0
XP_OPT_CMD_UTILITY=0
XP_CMD_UTILITY=""
XP_LAYOUT="${XP_DEFAULT_LAYOUT}"
XP_MAX_PANE_ARGS=""
XP_OPT_SET_TITLE=0
XP_OPT_CHANGE_BORDER=0
XP_OPT_EXTRA=0
XP_OPT_SPEEDY=0
XP_OPT_SPEEDY_AWAIT=0
XP_OPT_DEBUG="${XP_OPT_DEBUG:-0}"
XP_FOCUS_PANE_DSL="${XP_FOCUS_PANE_DSL:-}"
XP_OPT_SIZING=0
XP_SIZING_COLS=
XP_SIZING_ROWS=

## --------------------------------
# Logger
#   $1 -- Log level (i.e Warning, Error)
#   $2 -- Message
#   i.e
#      xpanes:Error: invalid option.
#
# This log format is created with reference to openssl's one.
#   $ echo | openssl -a
#   openssl:Error: '-a' is an invalid command.
## --------------------------------
xpns_msg() {
  local _loglevel="$1"
  local _msgbody="$2"
  local _msg="${XP_THIS_FILE_NAME}:${_loglevel}: ${_msgbody}"
  printf "%s\\n" "${_msg}" >&2
}

xpns_msg_n() {
  local _loglevel="$1"
  local _msgbody="$2"
  local _msg="${XP_THIS_FILE_NAME}:${_loglevel}: ${_msgbody}"
  printf "%s" "${_msg}" >&2
}

xpns_msg_info() {
  xpns_msg "Info" "$1"
}

xpns_msg_warning() {
  xpns_msg "Warning" "$1"
}

xpns_msg_debug() {
  if [[ $XP_OPT_DEBUG -eq 1 ]];then
    xpns_msg "Debug" "$(date "+[%F_%T]") $1"
  fi
}

xpns_msg_debug_n() {
  if [[ $XP_OPT_DEBUG -eq 1 ]];then
    xpns_msg_n "Debug" "$(date "+[%F_%T]") $1"
  fi
}


xpns_msg_error() {
  xpns_msg "Error" "$1"
}

xpns_usage() {
  cat << _EOS_
Usage:
  ${XP_THIS_FILE_NAME} [OPTIONS] [argument ...]

Usage(pipe mode):
  command ... | ${XP_THIS_FILE_NAME} [OPTIONS] [<utility> ...]

OPTIONS:
  -h,--help                    Show this screen.
  -V,--version                 Show version.
  -c <utility>                 Specify <utility> which is executed as a command in each panes. If <utility> is omitted, echo(1) is used.
  -d,--desync                  Make synchronize-panes option off on new window.
  -e                           Execute given arguments as is.
  -f <EXPRESSION>              Specify selected pane by default.
  -I <repstr>                  Replacing one or more occurrences of <repstr> in <utility> given by -c option. Default value of <repstr> is {}.
  -l <layout>                  Specify a layout for a window. Recognized layout arguments are:
                               t    tiled (default)
                               eh   even-horizontal
                               ev   even-vertical
                               mh   main-horizontal
                               mv   main-vertical
  -n <number>                  Set the maximum number of arguments taken for each pane of <utility>.
  -s                           Speedy mode: Run command without creating a login shell.
  -ss                          Speedy mode AND close the pane automatically at the same time as the process ends.
  -S <socket-path>             Specify a full alternative path to the server socket.
  -t                           Display each argument on the each pane's border as their title.
  -x                           Create extra panes in the current active window.
  --log[=<directory>]          Enable logging and store log files to ~/.cache/xpanes/logs or given <directory>.
  --log-format=<FORMAT>        File name of log files follow given <FORMAT>.
  --ssh                        Same as \`-t -s -c 'ssh -o StrictHostKeyChecking=no {}'\`.
  --stay                       Do not switch to new window.
  --debug                      Print debug message.

_EOS_
}

xpns_usage_verbose() {
  cat << _EOS_
EXPRESSION:
    * Integer numbers.
    * \`-\` and \`+\` operators
    * Special variables
      FP (First pane), LP (Last pane), BP (Biggest pane), SP (Smallest pane)

    Example:
      Biggest pane is selected.
      $ xpanes -f BP A B C

      Third pane is selected (if index pane-base-index is 0).
      $ xpanes -f 2 A B C

      Select the third pane from the last pane.
      $ xpanes -f 'LP-2' A B C

FORMAT:
    Default value is "${XP_DEFAULT_TMUX_XPANES_LOG_FORMAT}"
    Interpreted sequences are:
    [:PID:]   Process id of the tmux session. (e.g, 41531)
    [:ARG:]   Argument name

    In addition, sequences same as date(1) command are available.

    For example:
    %Y   year  (e.g, 1960)
    %m   month (e.g, 01)
    %d   date  (e.g, 31)
    And etc.
    Other sequences are available. Please refer to date(1) manual.

Copyright (c) 2018 Yamada, Yasuhiro
Released under the MIT License.
https://github.com/greymd/tmux-xpanes
_EOS_
}

# Show version number
xpns_version() {
  echo "${XP_THIS_FILE_NAME} ${XP_VERSION}"
}

# Get version number for tmux
xpns_get_tmux_version() {
  local _tmux_version=""
  if ! ${TMUX_XPANES_EXEC} -V &> /dev/null; then
    # From tmux 0.9 to 1.3, there is no -V option.
    _tmux_version="tmux 0.9-1.3"
  else
    _tmux_version="$( ${TMUX_XPANES_EXEC} -V )"
  fi
  ( read -r _ _ver; echo "${_ver}" ) <<<"${_tmux_version}"
}

# Check whether the prefered tmux version is greater than host's tmux version.
# $1 ... Prefered version.
# $2 ... Host tmux version(optional).
# In case of tmux version is 1.7, the result will be like this.
# 0 is true, 1 is false.
##  arg  -> result
#   func 1.5  1.7 -> 0
#   func 1.6  1.7 -> 0
#   func 1.7  1.7 -> 0
#   func 1.8  1.7 -> 1
#   func 1.9  1.7 -> 1
#   func 1.9a 1.7 -> 1
#   func 2.0  1.7 -> 1
xpns_tmux_is_greater_equals() {
  local _check_version="$1"
  local _tmux_version="${2:-$(xpns_get_tmux_version)}"
  # Simple numerical comparison does not work because there is the version like "1.9a".
  if [[ "$( (echo "${_tmux_version}"; echo "${_check_version}") | sort -n | head -n 1)" != "${_check_version}" ]];then
    return 1
  else
    return 0
  fi
}

xpns_get_local_tmux_conf() {
  local _conf_name="$1"
  local _session="${2-}"
  {
    if [[ -z "${_session-}" ]];then
      ${TMUX_XPANES_EXEC} show-window-options
    else
      ${TMUX_XPANES_EXEC} -S "${_session}" show-window-options
    fi
  } | grep "^${_conf_name}" \
    | ( read -r _ _v; printf "%s\\n" "${_v}" )
}

xpns_get_global_tmux_conf() {
  local _conf_name="$1"
  local _session="${2-}"
  {
    if [[ -z "${_session-}" ]];then
      ${TMUX_XPANES_EXEC} show-window-options -g
    else
      ${TMUX_XPANES_EXEC} -S "${_session}" show-window-options -g
    fi
  } | grep "^${_conf_name}" \
    | ( read -r _ _v; printf "%s\\n" "${_v}" )
}

# Disable allow-rename because
# window separation does not work correctly
# if "allow-rename" option is on
xpns_suppress_allow_rename () {
  local _default_allow_rename="$1"
  local _session="${2-}"
  if [[ "${_default_allow_rename-}" == "on"  ]]; then
    ## Temporary, disable "allow-rename"
    xpns_msg_debug "'allow-rename' option is 'off' temporarily."
    if [[ -z "${_session-}" ]];then
      ${TMUX_XPANES_EXEC} set-window-option -g allow-rename off
    else
      ${TMUX_XPANES_EXEC} -S "${_session}" set-window-option -g allow-rename off
    fi
  fi
}

# Restore default "allow-rename"
# Do not write like 'xpns_restore_allow_rename "some value" "some value" > /dev/null'
# In tmux 1.6, 'tmux set-window-option' might be stopped in case of redirection.
xpns_restore_allow_rename () {
  local _default_allow_rename="$1"
  local _session="${2-}"
  if [[ "${_default_allow_rename-}" == "on"  ]]; then
    xpns_msg_debug "Restore original value of 'allow-rename' option."
    if [[ -z "${_session-}" ]];then
      ${TMUX_XPANES_EXEC} set-window-option -g allow-rename on
    else
      ${TMUX_XPANES_EXEC} -S "${_session}" set-window-option -g allow-rename on
    fi
  fi
}

# Make each line unique by adding index number
# echo aaa bbb ccc aaa ccc ccc | xargs -n 1 | xpns_unique_line
#  aaa-1
#  bbb-1
#  ccc-1
#  aaa-2
#  ccc-2
#  ccc-3
#
# Eval is used because associative array is not supported before bash 4.2
xpns_unique_line () {
  local _val_name
  while read -r line; do
    _val_name="__xpns_hash_$(printf "%s" "${line}" | xpns_value2key)"
    # initialize variable
    eval "${_val_name}=\${${_val_name}:-0}"
    # increment variable
    eval "${_val_name}=\$(( ++${_val_name} ))"
    printf "%s\\n" "${line}-$(eval printf "%s" "\$${_val_name}")"
  done
}

#
# Generate log file names from given arguments.
# Usage:
#        echo <arg1> <arg2> ... | xpns_log_filenames <FORMAT>
# Return:
#        File names.
# Example:
#        $ echo aaa bbb ccc aaa ccc ccc | xargs -n 1 | xpns_log_filenames '[:ARG:]_[:PID:]_%Y%m%d.log'
#        aaa-1_1234_20160101.log
#        bbb-1_1234_20160101.log
#        ccc-1_1234_20160101.log
#        aaa-2_1234_20160101.log
#        ccc-2_1234_20160101.log
#        ccc-3_1234_20160101.log
#
xpns_log_filenames () {
  local _arg_fmt="$1"
  local _full_fmt=
  _full_fmt="$(date "+${_arg_fmt}")"
  cat \
    | \
    # 1st argument + '-' + unique number (avoid same argument has same name)
    xpns_unique_line \
    | while read -r _arg
    do
      cat <<<"${_full_fmt}" \
        | sed "s/\\[:ARG:\\]/${_arg}/g" \
        | sed "s/\\[:PID:\\]/$$/g"
    done
}

## --------------------------------
# Normalize directory by making following conversion.
#  * Tilde expansion.
#  * Remove the slash '/' at the end of the dirname.
# Usage:
#        xpns_normalize_directory <direname>
# Return:
#        Normalized <dirname>
## --------------------------------
xpns_normalize_directory() {
  local _dir="$1"
  # Remove end of slash '/'
  _dir="${_dir%/}"
  # tilde expansion
  _dir="${_dir/#~/${HOME}}"
  printf "%s\\n" "${_dir}"
}

## --------------------------------
# Ensure existence of given directory
# Usage:
#        xpns_is_valid_directory <direname>
# Return:
#        Absolute path of the <dirname>
## --------------------------------
xpns_is_valid_directory() {
  local _dir="$1"
  local _checkfile="${XP_THIS_FILE_NAME}.$$"
  # Check directory.
  if [[ ! -d "${_dir}" ]]; then
    # Create directory
    if mkdir "${_dir}"; then
      xpns_msg_info "${_dir} is created."
    else
      xpns_msg_error "Failed to create ${_dir}"
      exit ${XP_ELOGDIR}
    fi
  fi
  # Try to create file.
  #   Not only checking directory permission,
  #   but also i-node and other misc situations.
  if ! touch "${_dir}/${_checkfile}"; then
    xpns_msg_error "${_dir} is not writable."
    rm -f "${_dir}/${_checkfile}"
    exit ${XP_ELOGWRITE}
  fi
  rm -f "${_dir}/${_checkfile}"
}

# Convert array to string which is can be used as command line argument.
# Usage:
#       xpns_arr2args <array object>
# Example:
#       array=(aaa bbb "ccc ddd" eee "f'f")
#       xpns_arr2args "${array[@]}"
#       @returns "'aaa' 'bbb' 'ccc ddd' 'eee' 'f\'f'"
# Result:
xpns_arr2args() {
  local _arg=""
  # If there is no argument, usage will be shown.
  if [[ $# -lt 1 ]]; then
    return 0
  fi
  for i in "$@" ;do
    _arg="${i}"
    # Use 'cat <<<"input"' command instead of 'echo',
    # because such the command recognizes option like '-e'.
    cat <<<"${_arg}" \
      | \
      # Escaping single quotations.
      sed "s/'/'\"'\"'/g" \
      | \
      # Surround argument with single quotations.
      sed "s/^/'/;s/$/' /" \
      | \
      # Remove new lines
      tr -d '\n'
  done
}

# Extract first field to generate window name.
# ex, $2     =  'aaa bbb ccc'
#   return   =  aaa-12345(PID)
xpns_generate_window_name() {
  local _unprintable_str="${1-}"; shift
  # Leave first 200 characters to prevent
  # the name exceed the maximum length of tmux window name (2000 byte).
  printf "%s\\n" "${1:-${_unprintable_str}}" \
    | ( read -r _name _ && printf "%s\\n" "${_name:0:200}-$$" )
}

# Convert string to another string which can be handled as tmux window name.
xpns_value2key() {
  od -v -tx1 -An  | tr -dc 'a-zA-Z0-9' | tr -d '\n'
}

# Restore string encoded by xpns_value2key function.
xpns_key2value() {
  read -r _key
  # shellcheck disable=SC2059
  printf "$(printf "%s" "$_key" | sed 's/../\\x&/g')"
}

# Remove empty lines
# This function behaves like `awk NF`
xpns_rm_empty_line() {
  { cat; printf "\\n";} | while IFS= read -r line;do
    # shellcheck disable=SC2086
    set -- ${line-}
    if [[ $# != 0 ]]; then
      printf "%s\\n" "${line}"
    fi
  done
}

# Extract matched patterns from string
# $ xpns_extract_matched "aaa123bbb" "[0-9]{3}"
# => "123"
xpns_extract_matched() {
  local _args="$1" ;shift
  local _regex="($1)"
  if [[ $_args =~ $_regex ]];then
    printf "%s" "${BASH_REMATCH[0]}"
  fi
}

# Enable logging feature to the all the panes in the target window.
xpns_enable_logging() {
  local _window_name="$1"     ; shift
  local _index_offset="$1"    ; shift
  local _log_dir="$1"         ; shift
  local _log_format="$1"      ; shift
  local _unprintable_str="$1" ; shift
  local _args=("$@")
  local _args_num=$(($# - 1))
  # Generate log files from arguments.
  local _idx=0
  while read -r _logfile ; do
    # Start logging
    xpns_msg_debug "xpns_enable_logging:Start logging pipe-pane(cat >> '${_log_dir}/${_logfile}')"
    ${TMUX_XPANES_EXEC} \
      pipe-pane -t "${_window_name}.$(( _idx + _index_offset ))" \
      "cat >> '${_log_dir}/${_logfile}'" # Tilde expansion does not work here.
    _idx=$(( _idx + 1 ))
  done < <(
  for i in $(xpns_seq 0 "${_args_num}")
  do
    # Replace empty string.
    printf "%s\\n" "${_args[i]:-${_unprintable_str}}"
  done | xpns_log_filenames "${_log_format}"
  )
}

xpns_notify() {
  local _wait_id="$1" ; shift
  local _fifo
  _fifo="${XP_CACHE_HOME}/__xpns_${_wait_id}"
  xpns_msg_debug "xpns_notify:Notify to $_fifo"
  printf "%s\\n" 1 > "$_fifo" &
}

xpns_delete_notify() {
  local _wait_id="$1" ; shift
  local _fifo
  _fifo="${XP_CACHE_HOME}/__xpns_${_wait_id}"
  xpns_msg_debug "xpns_delete_notify:Delete $_fifo"
  rm -f "$_fifo"
}

xpns_notify_logging() {
  local _window_name="$1" ; shift
  local _args_num=$(($# - 1))
  for i in $(xpns_seq 0 "${_args_num}"); do
    xpns_notify "log_${_window_name}-${i}-$$"
  done
}

xpns_notify_title() {
  local _window_name="$1" ; shift
  local _args_num=$(($# - 1))
  for i in $(xpns_seq 0 "${_args_num}"); do
    xpns_notify "title_${_window_name}-${i}-$$"
  done
}

xpns_is_window_alive() {
  local _window_name="$1" ;shift
  local _speedy_await_flag="$1" ;shift
  local _def_allow_rename="$1" ;shift
  if ! ${TMUX_XPANES_EXEC} display-message -t "$_window_name" -p > /dev/null 2>&1 ;then
    xpns_msg_info "All the panes are closed before displaying the result."
    if [[ "${_speedy_await_flag}" -eq 0 ]] ;then
      xpns_msg_info "Use '-s' option instead of '-ss' option to avoid this behavior."
    fi
    xpns_restore_allow_rename "${_def_allow_rename-}"
    exit ${XP_ENOPANE}
  fi
}

xpns_inject_title() {
  local _target_pane="$1" ;shift
  local _message="$1"     ;shift
  local _pane_tty
  _pane_tty="$( ${TMUX_XPANES_EXEC} display-message -t "${_target_pane}" -p "#{pane_tty}" )"
  printf "\\033]2;%s\\033\\\\" "${_message}" > "${_pane_tty}"
  xpns_msg_debug "xpns_inject_title:target_pane=${_target_pane} pane_title=${_message} pane_tty=${_pane_tty}"
}

xpns_is_pane_title_required() {
  local _title_flag="$1"   ; shift
  local _extra_flag="$1"  ; shift
  local _pane_border_status
  _pane_border_status=$(xpns_get_local_tmux_conf "pane-border-status")
  if [[ $_title_flag -eq 1 ]]; then
    return 0
  elif [[ ${_extra_flag} -eq 1 ]] && \
       [[ "${_pane_border_status}" != "off" ]] && \
       [[ -n "${_pane_border_status}" ]] ;then
    ## For -x option
    # Even the -t option is not specified, it is required to inject pane title here.
    # Because user expects the title is displayed on the pane if the original window is
    # generated from tmux-xpanes with -t option.
    return 0
  fi
  return 1
}

# Set pane titles for each pane for -t option
xpns_set_titles() {
  local _window_name="$1"  ; shift
  local _index_offset="$1" ; shift
  local _index=0
  local _pane_index
  for arg in "$@"
  do
    _pane_index=$(( _index + _index_offset ))
    xpns_inject_title "${_window_name}.${_pane_index}" "${arg}"
    _index=$(( _index + 1 ))
  done
}

# Send command to the all the panes in the target window.
xpns_send_commands() {
  local _window_name="$1"  ; shift
  local _index_offset="$1" ; shift
  local _repstr="$1"       ; shift
  local _cmd="$1"          ; shift
  local _index=0
  local _pane_index
  for arg in "$@"
  do
    _pane_index=$(( _index + _index_offset ))
    ${TMUX_XPANES_EXEC} send-keys -t "${_window_name}.${_pane_index}" "${_cmd//${_repstr}/${arg}}" C-m
    _index=$(( _index + 1 ))
  done
}

# Separate window vertically, when the number of panes is 1 or 2.
xpns_arrange_pane_location() {
  local _window_name="$1" ; shift
  local _args_num="$1"
  ## ----------------
  # Default behavior
  ## ----------------
  if [[ "${_args_num}" -eq 1 ]]; then
    ${TMUX_XPANES_EXEC} select-layout -t "${_window_name}" even-horizontal
  elif [[ "${_args_num}" -gt 1 ]]; then
    ${TMUX_XPANES_EXEC} select-layout -t "${_window_name}" tiled
  fi
  ## ----------------
  # Update layout
  ## ----------------
  if [[ "${XP_LAYOUT}" != "${XP_DEFAULT_LAYOUT}" ]]; then
    ${TMUX_XPANES_EXEC} select-layout -t "${_window_name}" "${XP_LAYOUT}"
  fi
}

#
# Generate sequential number descending order.
# seq is not used because old version of
# seq does not generate descending oorder.
# $ xpns_seq 3 0
# 3
# 2
# 1
# 0
#
xpns_seq () {
  local _num1="$1"
  local _num2="$2"
  eval "printf \"%d\\n\" {$_num1..$_num2}"
}

xpns_wait_func() {
  local _wait_id="$1"
  local _fifo="${XP_CACHE_HOME}/__xpns_${_wait_id}"
  local _arr=("$_fifo")
  local _fifo_arg=
  _fifo_arg=$(xpns_arr2args "${_arr[@]}")
  xpns_msg_debug "xpns_wait_func: mkfifo $_fifo"
  mkfifo "${_fifo}"
  xpns_msg_debug "xpns_wait_func: grep -q 1 ${_fifo_arg}"
  printf "%s\\n" "grep -q 1 ${_fifo_arg}"
}

# Split a new window into multiple panes.
#
xpns_split_window() {
  local _window_name="$1"     ; shift
  local _log_flag="$1"        ; shift
  local _title_flag="$1"      ; shift
  local _cmd_exec_flag="$1"   ; shift
  local _await_flag="$1"      ; shift
  local _pane_base_index="$1" ; shift
  local _repstr="$1"          ; shift
  local _cmd_template="$1"    ; shift
  local _exec_cmd
  local _sep_count=0
  local args=("$@")
  _last_idx=$(( ${#args[@]} - 1 ))

  # TODO: implement sizing feature
  if [[ $XP_OPT_SIZING -eq 1 ]]; then
    local row=$XP_SIZING_ROWS
    local col=$XP_SIZING_COLS
    local cell_width=$XP_CELL_WIDTH
    local cell_height=$XP_CELL_HEIGHT
    local rest_N=$XP_CELL_NUM

    for (( i = 0 ; i < row ; i++ ));do
      # Adjust cell width at the last row
      if (( i == row - 1 )); then
        cell_width=$(( XP_WINDOW_WIDTH / rest_N ))
      fi
      # tmux split-window -v -l 30 -db -F '#{pane_id}' -P "echo 1; read"
      pane_id=$(${TMUX_XPANES_EXEC} split-window -v -b -d -l "${cell_height}" -F '#{pane_id}' -P)
      for (( j = 0 ; j < col ; j++ ));do
        idx=$(( i * col + j ))
        if (( idx < ${#args[@]} )); then
          # tmux split-window -t '%85' -h -l $((152 - 60)) -d -F '#{pane_id}' -P "echo 2; read"
          pane_id=$(${TMUX_XPANES_EXEC} split-window -t "${pane_id}" -h -d -l $(( XP_WINDOW_WIDTH - cell_width * ( j + 1 ) )) -F '#{pane_id}' -P)
          xpns_msg_debug_n "[ $i * $j = ${args[idx]} ${cell_height}x${cell_width}] "
          (( rest_N = rest_N - 1 ))
        fi
      done
      xpns_msg_debug "\\n"
    done

  else

    for i in $(xpns_seq $_last_idx 0) ;do
      xpns_msg_debug "Index:${i} Argument:${args[i]}"
      _sep_count=$((_sep_count + 1))
      _exec_cmd="${_cmd_template//${_repstr}/${args[i]}}"

      ## Speedy mode
      if [[ $_cmd_exec_flag -eq 1 ]]; then

        ## Speedy mode + logging
        if [[ ${_log_flag} -eq 1 ]];then
          # Wait for start of logging
          # Without this part, logging thread may start after new process is finished.
          # Execute function to wait for logging start.
          _exec_cmd="$(xpns_wait_func "log_${_window_name}-${i}-$$")"$'\n'"${_exec_cmd}"
        fi

        ## Speedy mode + pane title
        if [[ ${_title_flag} -eq 1 ]];then
          _exec_cmd="$(xpns_wait_func "title_${_window_name}-${i}-$$")"$'\n'${_exec_cmd}
        fi

        ## -ss: Speedy mode + nowait
        if [[ $_await_flag -eq 1 ]]; then
          _exec_cmd="${_exec_cmd}${XP_AWAIT_CMD}"
        fi

        # Execute command as a child process of default-shell.
        ${TMUX_XPANES_EXEC} split-window -t "${_window_name}" -h -d "${_exec_cmd}"
      else
        # Open login shell and execute command on the interactive screen.
        ${TMUX_XPANES_EXEC} split-window -t "${_window_name}" -h -d
      fi
      # Restraining that size of pane's width becomes
      # less than the minimum size which is defined by tmux.
      if [[ ${_sep_count} -gt 2 ]] && [[ $XP_OPT_SIZING -eq 0 ]]; then
        ${TMUX_XPANES_EXEC} select-layout -t "${_window_name}" tiled
      fi
    done
  fi
}

#
# Create new panes to the  existing window.
# Usage:
#    func <window name> <offset of index> <number of pane>
#
xpns_extra_panes_to_window() {
  local _window_name="$1"     ; shift
  local _pane_base_index="$1" ; shift
  local _log_flag="$1"        ; shift
  local _title_flag="$1"      ; shift
  local _speedy_flg="$1"      ; shift
  local _await_flg="$1"       ; shift
  # specify a pane which has the biggest index number.
  #   Because pane_id may not be immutable.
  #   If the small number of index is specified here, correspondance between pane_title and command can be slip off.
  ${TMUX_XPANES_EXEC} select-pane -t "${_window_name}.${_pane_base_index}"

  # split window into multiple panes
  xpns_split_window \
    "${_window_name}" \
    "${_log_flag}" \
    "${_title_flag}" \
    "${_speedy_flg}" \
    "${_await_flg}" \
    "${_pane_base_index}" \
    "$@"
}

#
# Split a new window which was created by tmux into multiple panes.
# Usage:
#    xpns_prepare_window <window name> <offset of index> <number of pane> <attach or not>
#
xpns_prepare_window() {
  local _window_name="$1"     ; shift
  local _pane_base_index="$1" ; shift
  local _log_flag="$1"        ; shift
  local _title_flag="$1"      ; shift
  local _attach_flg="$1"      ; shift
  local _speedy_flg="$1"      ; shift
  local _await_flg="$1"       ; shift
  # Create new window.
  if [[ "${_attach_flg}" -eq 1 ]]; then
    ${TMUX_XPANES_EXEC} new-window -n "${_window_name}"
  else
    # Keep background
    ${TMUX_XPANES_EXEC} new-window -n "${_window_name}" -d
  fi

  # specify a pane which has the youngest number of index.
  ${TMUX_XPANES_EXEC} select-pane -t "${_window_name}.${_pane_base_index}"

  # split window into multiple panes
  xpns_split_window \
    "${_window_name}" \
    "${_log_flag}" \
    "${_title_flag}" \
    "${_speedy_flg}" \
    "${_await_flg}" \
    "${_pane_base_index}" \
    "$@"

  ### If the first pane is still remaining,
  ### panes cannot be organized well.
  # Delete the first pane
  ${TMUX_XPANES_EXEC} kill-pane -t "${_window_name}.${_pane_base_index}"

  # Select second pane here.
  #   If the command gets error, it would most likely be caused by user (XP_ENOPANE).
  #   Suppress error message here and announce it in xpns_execution.
  ${TMUX_XPANES_EXEC} select-pane -t "${_window_name}.${_pane_base_index}" > /dev/null 2>&1
}

# Check whether given command is in the PATH or not.
xpns_check_env() {
  local _cmds="$1"
  while read -r cmd ; do
    if ! type "${cmd}" > /dev/null 2>&1; then
      if [[ "${cmd}" == "tmux" ]] && [[ "${TMUX_XPANES_EXEC}" == "tmux" ]]; then
        xpns_msg_error "${cmd} is required. Install ${cmd} or set TMUX_XPANES_EXEC variable."
        exit ${XP_ENOCMD}
      elif [[ "${cmd}" != "tmux" ]]; then
        xpns_msg_error "${cmd} is required."
        exit ${XP_ENOCMD}
      fi
    fi
  done < <(echo "${_cmds}" | tr ' ' '\n')

  if ! mkdir -p "${XP_CACHE_HOME}";then
    xpns_msg_warning "failed to create cache directory '${XP_CACHE_HOME}'."
  fi

  # Do not omit this part, this is used by testing.
  XP_HOST_TMUX_VERSION="${XP_HOST_TMUX_VERSION:-$(xpns_get_tmux_version)}"
  if ( xpns_tmux_is_greater_equals \
    "${XP_SUPPORT_TMUX_VERSION_LOWER}" \
    "${XP_HOST_TMUX_VERSION}" ) ;then
    : "Supported tmux version"
  else
    xpns_msg_warning \
"'${XP_THIS_FILE_NAME}' may not work correctly! Please check followings.
* tmux is installed correctly.
* Supported tmux version is installed.
  Version ${XP_SUPPORT_TMUX_VERSION_LOWER} and over is officially supported."
  fi

  return 0
}

xpns_pipe_filter() {
  local _number="${1-}"
  if [[ -z "${_number-}" ]]; then
    cat
  else
    xargs -n "${_number}"
  fi
}

xpns_set_args_per_pane() {
  local _pane_num="$1"; shift
  local _filtered_args=()
  while read -r _line; do
    _filtered_args+=("${_line}")
  done < <(xargs -n "${_pane_num}" <<<"$(xpns_arr2args "${XP_ARGS[@]}")")
  XP_ARGS=("${_filtered_args[@]}")
}

## ----------------
# Arrange options for pipe mode
#  * argument -> command utility
#  * stdin -> argument
## ----------------
xpns_switch_pipe_mode() {
  local _pane_num4new_term=""
  if [[ ! -z "${XP_ARGS[*]-}" ]] && [[ ! -z "${XP_CMD_UTILITY-}" ]]; then
    xpns_msg_error "Both arguments and other options (like '-c', '-e') which updates <utility> are given."
    exit ${XP_EINVAL}
  fi

  if [[ -z "${TMUX-}" ]]; then
    xpns_msg_warning "Attached session is required for 'Pipe mode'."
    # This condition is used when the following situations.
    #   * Enter from outside of tmux session(Normal mode1)
    #   * Pipe mode.
    #   * -n option.
    #
    # For example:
    #     (Normal mode1)$ echo {a..g} | ./xpanes -n 2
    # => This will once create the new window like this.
    #     (inside of tmux session)$ ./xpanes '-n' '2' 'a' 'b' 'c' 'd' 'e' 'f' 'g'
    #     => After the window is closed, following panes would be left.
    #     (pane 1)$ echo a b
    #     (pane 2)$ echo c d
    #     (pane 3)$ echo e f
    #     (pane 4)$ echo g
    # In order to create such the query,
    # separate all the argument into minimum tokens
    # with xargs -n 1
    if [[ -n "${XP_MAX_PANE_ARGS-}" ]]; then
      _pane_num4new_term=1
    fi
  fi

  while read -r line;
  do
    XP_STDIN+=("${line}")
  done < <(cat | xpns_rm_empty_line | \
    xpns_pipe_filter "${_pane_num4new_term:-${XP_MAX_PANE_ARGS}}")


  # Merge them into utility.
  if [[ ! -z "${XP_ARGS[*]-}" ]]; then
    # Attention: It might be wrong result if IFS is changed.
    XP_CMD_UTILITY="${XP_ARGS[*]}"
  fi

  # If there is empty -I option or user does not assign the <repstr>,
  # Append the space and <repstr> at the end of the <utility>
  # This is same as the xargs command of GNU.
  # i.e,
  #   $ echo 10 | xargs seq
  #     => seq 10
  # Whith is same as
  #   $ echo 10 | xargs -I@ seq @
  #     => seq 10
  if [[ -z "${XP_REPSTR}" ]]; then
    XP_REPSTR="${XP_DEFAULT_REPSTR}"
    if [[ ! -z "${XP_ARGS[*]-}" ]]; then
      XP_CMD_UTILITY="${XP_ARGS[*]-} ${XP_REPSTR}"
    fi
  fi

  # Deal with stdin as arguments.
  XP_ARGS=("${XP_STDIN[@]-}")
}

xpns_layout_short2long() {
  sed \
    -e 's/^t$/tiled/' \
    -e 's/^eh$/even-horizontal/' \
    -e 's/^ev$/even-vertical/' \
    -e 's/^mh$/main-horizontal/' \
    -e 's/^mv$/main-vertical/' \
    -e ';'
}

xpns_is_valid_layout() {
  local _layout="${1-}"
  local _pat='^(tiled|even-horizontal|even-vertical|main-horizontal|main-vertical)$'
  if ! [[ $_layout =~ $_pat ]]  ; then
    xpns_msg_error "Invalid layout '${_layout}'."
    exit ${XP_ELAYOUT}
  fi
}

xpns_DSL_biggest_pane () {
  local idx
  local max=0
  while read -r _idx _height _width; do
    _size=$(( _height * _width ))
    if (( _size > max )) ;then
      idx="$_idx"
      max="$_size"
    fi
  done
  printf "%s\\n" "$idx"
}

xpns_DSL_smallest_pane () {
  local idx
  local min=0
  while read -r _idx _height _width; do
    _size=$(( _height * _width ))
    # Initialize min
    if (( min == 0 )) || (( _size < min )) ;then
      idx="$_idx"
      min="$_size"
    fi
  done
  printf "%s\\n" "$idx"
}

xpns_DSL_syntax_check () {
  local _dsl="$1"
  local _pat='^([\+-]| |LP|FP|BP|SP|[0-9])+$'
  if ! [[ $_dsl =~ $_pat ]]; then
    xpns_msg_error "-f option syntax error '$_dsl'"
    return 1
  fi
  xpns_msg_debug "xpns_DSL_syntax_check: syntax check succeeded"
  return 0
}

xpns_DSL_result_check () {
  local _result="$1"
  local _pat='^[0-9]+$'
  if ! [[ $_result =~ $_pat ]]; then
    return 1
  fi
  return 0
}

xpns_DSL_execute () {
  local _dsl="$1"
  local _res
  local _panes
  local LP FP BP SP

  # syntax check is already implementd in the xpns_load_arg_options
  # Skip xpns_DSL_syntax_check

  _panes="$(${TMUX_XPANES_EXEC} list-panes -F '#{pane_index} #{pane_height} #{pane_width}')"
  xpns_msg_debug "xpns_DSL_execute: list-panes: $( echo "${_panes}" | tr '\n' '/' )"
  # shellcheck disable=SC2034
  FP="$(echo "$_panes" | { read -r _idx _ _; echo "${_idx}"; } )"
  xpns_msg_debug "xpns_DSL_execute: FP = $FP"
  # shellcheck disable=SC2034
  LP="$(echo "$_panes" | tail -n 1 | { read -r _idx _ _; echo "${_idx}"; } )"
  xpns_msg_debug "xpns_DSL_execute: LP = $LP"
  # shellcheck disable=SC2034
  BP="$(echo "$_panes" | xpns_DSL_biggest_pane)"
  xpns_msg_debug "xpns_DSL_execute: BP = $BP"
  # shellcheck disable=SC2034
  SP="$(echo "$_panes" | xpns_DSL_smallest_pane)"
  xpns_msg_debug "xpns_DSL_execute: SP = $SP"
  # execute formula
  _res=$(( _dsl ))
  xpns_msg_debug "xpns_DSL_execute: execute [$_dsl]: result [$_res]"
  if ! xpns_DSL_result_check "$_res" ;then
    xpns_msg_warning "Given DSL [$_dsl] returns invalid result [$_res]"
    return 2
  fi
  printf "%s\\n" "$_res"
  return 0
}

xpns_warning_before_extra() {
  local _ans _synchronized
  _synchronized="$(xpns_get_local_tmux_conf "synchronize-panes")"
  if [[ "on" == "${_synchronized}" ]];then
    xpns_msg_warning "Panes are now synchronized.
'-x' option may cause unexpected behavior on the synchronized panes."
    printf "Are you really sure? [y/n]: "
    read -r _ans
    if ! [[ "${_ans-}" =~ ^[yY]  ]]; then
      return 1
    fi
  fi
}

# Adjust size of columns and rows in accordance with given N
# func <col> <row> <N>
# i.e:
#     func "" "" 20
#       => returns 4 5
#     func "6" 0 20
#       => returns 6 4
xpns_adjust_col_row() {
  local col="${1:-0}" ;shift
  local row="${1:-0}" ;shift
  local N="$1"   ;shift
  local fix_col
  local fix_row
  (( col != 0 )) && fix_col=1
  (( row != 0 )) && fix_row=1

  # If both valures are specified, col is used
  if (( fix_col == 1 )) && (( fix_row == 1 ));then
    row=0
    fix_row=0
  fi
  ## xpns_msg_debug "xpns_adjust_col_row(given): col=$col row=$row fix_col=$fix_col fix_row=$fix_row"
  while (( col * row < N )) ;do
    (( fix_row != 1 )) && (( row = row + 1 ))
    if (( col * row < N ));then
      (( fix_col != 1 )) &&  (( col = col + 1 ))
    fi
  done
  ## xpns_msg_debug "xpns_adjust_col_row(result): col=$col row=$row fix_col=$fix_col fix_row=$fix_row"
  printf "%d %d\\n" "${col}" "${row}"
}

xpns_load_flag_options() {
  if [[ "$1" =~ h ]]; then
    xpns_usage
    xpns_usage_verbose
    exit 0
  fi
  if [[ "$1" =~ V ]]; then
    xpns_version
    exit 0
  fi
  if [[ "$1" =~ x ]]; then
    XP_OPT_EXTRA=1
    if ! xpns_warning_before_extra; then
      exit ${XP_EINTENT}
    fi
  fi
  if [[ "$1" =~ d ]]; then
    XP_OPT_IS_SYNC=0
  fi
  if [[ "$1" =~ e ]]; then
    XP_REPSTR="{}"
    XP_CMD_UTILITY="{}"
  fi
  if [[ "$1" =~ t ]]; then
    if ( xpns_tmux_is_greater_equals 2.3 ) ; then
      XP_OPT_SET_TITLE=1
      XP_OPT_CHANGE_BORDER=1
    else
      xpns_msg_warning "-t option cannot be used by tmux version less than 2.3. Disabled."
      sleep 1
    fi
  fi
  if [[ "$1" =~ s ]]; then
    XP_OPT_SPEEDY=1
    XP_OPT_SPEEDY_AWAIT=1
  fi
  if [[ "$1" =~ ss ]]; then
    XP_OPT_SPEEDY_AWAIT=0
  fi
  return 1
}

xpns_load_arg_options() {
  # Extract flag options only.
  local _pattern
  xpns_load_flag_options "$(xpns_extract_matched "$1" "^-${XP_FLAG_OPTIONS}+")" > /dev/null
  if [[ "$1" =~ ^-${XP_FLAG_OPTIONS}*I ]]; then
    # Behavior like this.
    # -IAAA       -- XP_REPSTR="AAA"
    # -I AAA BBB  -- XP_REPSTR="AAA", XP_ARGS=("BBB")
    # -I"AAA BBB" -- XP_REPSTR="AAA BBB"
    # -IAAA BBB   -- XP_REPSTR="AAA", XP_ARGS=("BBB")
    # -I -d ...   -- XP_REPSTR=""
    _pattern="^-${XP_FLAG_OPTIONS}*I(.+)"
    if [[ "$1" =~ $_pattern ]]; then
      XP_REPSTR="${BASH_REMATCH[1]}"
      return 0
    elif ! [[ "$2" =~ ^-.* ]]; then
      XP_REPSTR="$2"
      return 0
    else
      xpns_msg_error "invalid argument '$2' for -I option"
      exit ${XP_EINVAL}
    fi
  elif [[ "$1" =~ ^-${XP_FLAG_OPTIONS}*l ]]; then
    _pattern="^-${XP_FLAG_OPTIONS}*l(.+)"
    if [[ "$1" =~ $_pattern ]]; then
      XP_LAYOUT="$(cat <<<"${BASH_REMATCH[1]}" | xpns_layout_short2long)"
      xpns_is_valid_layout "${XP_LAYOUT}"
      return 0
    elif ! [[ "$2" =~ ^-.* ]]; then
      XP_LAYOUT="$(cat <<<"$2" |  xpns_layout_short2long )"
      xpns_is_valid_layout "${XP_LAYOUT}"
      return 0
    else
      xpns_msg_error "invalid argument '$2' for -l option"
      exit ${XP_EINVAL}
    fi
  elif [[ "$1" =~ ^-${XP_FLAG_OPTIONS}*c ]]; then
    _pattern="^-${XP_FLAG_OPTIONS}*c(.+)"
    if [[ "$1" =~ $_pattern ]]; then
      XP_CMD_UTILITY="${BASH_REMATCH[1]}"
      XP_OPT_CMD_UTILITY=1
      return 0
    elif ! [[ "$2" =~ ^-.* ]]; then
      XP_CMD_UTILITY="$2"
      XP_OPT_CMD_UTILITY=1
      return 0
    else
      xpns_msg_error "invalid argument '$2' for -c option"
      exit ${XP_EINVAL}
    fi
  elif [[ "$1" =~ ^-${XP_FLAG_OPTIONS}*n ]]; then
    _pattern="^-${XP_FLAG_OPTIONS}*n([0-9]+)"
    if [[ "$1" =~ $_pattern ]]; then
      XP_MAX_PANE_ARGS="${BASH_REMATCH[1]}"
      return 0
    elif [[ "$2" =~ ^[0-9]+$ ]]; then
      XP_MAX_PANE_ARGS="$2"
      return 0
    else
      xpns_msg_error "invalid argument '$2' for -n option"
      exit ${XP_EINVAL}
    fi
  elif [[ "$1" =~ ^-${XP_FLAG_OPTIONS}*S ]]; then
    _pattern="^-${XP_FLAG_OPTIONS}*S(.+)"
    if [[ "$1" =~ $_pattern ]]; then
      XP_SOCKET_PATH="${BASH_REMATCH[1]}"
      return 0
    elif ! [[ "$2" =~ ^-.* ]]; then
      XP_SOCKET_PATH="$2"
      return 0
    else
      xpns_msg_error "invalid argument '$2' for -S option"
      exit ${XP_EINVAL}
    fi
  elif [[ "$1" =~ ^-${XP_FLAG_OPTIONS}*f ]]; then
    _pattern="^-${XP_FLAG_OPTIONS}*f(.+)"
    if [[ "$1" =~ $_pattern ]]; then
      XP_FOCUS_PANE_DSL="${BASH_REMATCH[1]}"
      if ! xpns_DSL_syntax_check "$XP_FOCUS_PANE_DSL";then
        exit ${XP_ESYNTAX}
      fi
      return 0
    elif ! [[ "$2" =~ ^-.* ]];then
      XP_FOCUS_PANE_DSL="$2"
      if ! xpns_DSL_syntax_check "$XP_FOCUS_PANE_DSL";then
        exit ${XP_ESYNTAX}
      fi
      return 0
    else
      xpns_msg_error "invalid argument '$2' for -f option"
      exit ${XP_EINVAL}
    fi
  fi
  return 0
}

xpns_load_long_options() {
  if [[ "$1" =~ ^--help$ ]]; then
    xpns_usage
    xpns_usage_verbose
    exit 0
  elif [[ "$1" =~ ^--version$ ]]; then
    xpns_version
    exit 0
  elif [[ "$1" =~ ^--desync$ ]]; then
    XP_OPT_IS_SYNC=0
    return 1
  elif [[ "$1" =~ ^--col=.*$ ]]; then
    XP_OPT_SIZING=1
    XP_SIZING_COLS="${1#--col=}"
    if ! [[ "$XP_SIZING_COLS" =~ ^[0-9]+$ ]]; then
      xpns_msg_error "invalid argument '$XP_SIZING_COLS' for --col option"
      exit ${XP_EINVAL}
    fi
    return 1
  elif [[ "$1" =~ ^--row=.*$ ]]; then
    XP_OPT_SIZING=1
    XP_SIZING_ROWS="${1#--row=}"
    if ! [[ "$XP_SIZING_ROWS" =~ ^[0-9]+$ ]]; then
      xpns_msg_error "invalid argument '$XP_SIZING_ROWS' for --row option"
      exit ${XP_EINVAL}
    fi
    return 1
  elif [[ "$1" =~ ^--log-format=.*$ ]]; then
    XP_OPT_LOG_STORE=1
    TMUX_XPANES_LOG_FORMAT="${1#--log-format=}"
    return 1
  elif [[ "$1" =~ ^--log ]]; then
    XP_OPT_LOG_STORE=1
    if [[ "$1" =~ ^--log=.*$  ]]; then
      TMUX_XPANES_LOG_DIRECTORY="${1#--log=}"
    fi
    return 1
  elif [[ "$1" =~ ^--ssh$ ]]; then
    XP_CMD_UTILITY="${XP_SSH_CMD_UTILITY}"
    # Enable -t option as well
    XP_OPT_SET_TITLE=1
    XP_OPT_CHANGE_BORDER=1
    # Enable -s option
    XP_OPT_SPEEDY=1
    XP_OPT_SPEEDY_AWAIT=1
    return 1
    # For unit testing
  elif [[ "$1" =~ ^--dry-run$ ]]; then
    XP_OPT_DRY_RUN=1
    return 1
  elif [[ "$1" =~ ^--stay$ ]]; then
    XP_OPT_ATTACH=0
    return 1
  elif [[ "$1" =~ ^--debug$ ]]; then
    XP_OPT_DEBUG=1
    return 1

  ## ----------------
  # Other options
  ## ----------------
  else
    xpns_msg_error "invalid option -- '${1#--}'"
    xpns_usage
    echo "Try '${XP_THIS_FILE_NAME} --help' for more information." >&2
    exit ${XP_EINVAL}
  fi
}

xpns_parse_options() {
  while (( $# > 0 ))
  do
    case "$1" in
      --)
      if [[ ${XP_NO_OPT} -eq 1 ]]; then
        XP_ARGS+=("$1")
        shift
      else
        # Disable any more options
        XP_NO_OPT=1
        shift
      fi
      ;;
      ## ----------------
      # Long options
      ## ----------------
      --*)
      if [[ ${XP_NO_OPT} -eq 1 ]]; then
        XP_ARGS+=("$1")
        shift
      else
        local _shift_count="0"
        xpns_load_long_options "$@"
        _shift_count="$?"
        [[ "${_shift_count}" = "1" ]] && XP_OPTIONS+=("$1") && shift
      fi
      ;;
      ## ----------------
      # Short options
      ## ----------------
      -*)
      if [[ ${XP_NO_OPT} -eq 1 ]]; then
        XP_ARGS+=("$1")
        shift
      else
        local _shift_count="0"
        if [[ "$1" =~ ^-${XP_FLAG_OPTIONS}*${XP_ARG_OPTIONS}. ]];then
          xpns_load_arg_options "$@"
          XP_OPTIONS+=("$1") && shift
        elif [[ "$1" =~ ^-${XP_FLAG_OPTIONS}*${XP_ARG_OPTIONS}$ ]] && [[ -n "${2-}" ]];then
          xpns_load_arg_options "$@"
          _shift_count="$?"
          XP_OPTIONS+=("$1" "$2") && shift && shift
        elif [[ "$1" =~ ^-${XP_FLAG_OPTIONS}+$  ]];then
          xpns_load_flag_options "$1"
          XP_OPTIONS+=("$1") && shift
        ## ----------------
        # Other options
        ## ----------------
        else
          xpns_msg_error "Invalid option -- '${1#-}'"
          xpns_usage
          echo "Try '${XP_THIS_FILE_NAME} --help' for more information." >&2
          exit ${XP_EINVAL}
        fi
      fi
      ;;
      ## ----------------
      # Other arguments
      ## ----------------
      *)
      XP_ARGS+=("$1")
      XP_NO_OPT=1
      shift
      ;;
    esac
  done

  # If there is any standard input from pipe,
  # 1 line handled as 1 argument.
  if [[ ! -t 0 ]]; then
    XP_IS_PIPE_MODE=1
    xpns_switch_pipe_mode
  fi

  # When no argument arr given, exit.
  if [[ -z "${XP_ARGS[*]-}" ]]; then
    xpns_msg_error "No arguments are given."
    xpns_usage
    echo "Try '${XP_THIS_FILE_NAME} --help' for more information." >&2
    exit ${XP_EINVAL}
  fi

  # Set default value in case of empty.
  XP_CMD_UTILITY="${XP_CMD_UTILITY:-${XP_DEFAULT_CMD_UTILITY}}"
  XP_REPSTR="${XP_REPSTR:-${XP_DEFAULT_REPSTR}}"

  # To set utility on pre_execution, set -c option manually.
  if [[ ${XP_OPT_CMD_UTILITY} -eq 0 ]];then
    XP_OPTIONS+=("-c" "${XP_CMD_UTILITY}")
  fi

  if [[ ${XP_OPT_SIZING} -eq 1 ]];then
    # TODO: Declare following variables on the top of the file
    read -r XP_SIZING_COLS XP_SIZING_ROWS    < <(xpns_adjust_col_row "${XP_SIZING_COLS-}" "${XP_SIZING_ROWS-}" "${#XP_ARGS[@]}")
    read -r XP_WINDOW_WIDTH XP_WINDOW_HEIGHT < <(${TMUX_XPANES_EXEC} display-message -p '#{window_width} #{window_height}')
    XP_CELL_HEIGHT=$(( XP_WINDOW_WIDTH / XP_SIZING_COLS ))
    XP_CELL_WIDTH=$(( XP_WINDOW_HEIGHT / XP_SIZING_ROWS ))
    XP_CELL_NUM="${#XP_ARGS[@]}"
  fi

  ## Showing basic information
  xpns_msg_debug "Window: [ Height: $XP_WINDOW_WIDTH Width: $XP_WINDOW_WIDTH]"
  xpns_msg_debug "Basic Pane size: [ Height: $XP_CELL_HEIGHT Width: $XP_CELL_WIDTH]"
  xpns_msg_debug "# Of Panes: ${XP_CELL_NUM}"
  xpns_msg_debug "    -- Cols: ${XP_SIZING_COLS} Rows: ${XP_SIZING_ROWS}"
  xpns_msg_debug "Options: $(xpns_arr2args "${XP_OPTIONS[@]}")"
  xpns_msg_debug "Arguments: $(xpns_arr2args "${XP_ARGS[@]}")"
}

# Execute from Normal mode1
xpns_pre_execution() {
  local _opts4args=""
  local _args4args=""

  if [[ ${XP_OPT_EXTRA} -eq 1 ]];then
    xpns_msg_error "'-x' must be used within the running tmux session."
    exit ${XP_EINVAL}
  fi

  # Append -- flag.
  # Because any arguments may have `-`
  if [[ ${XP_NO_OPT} -eq 1 ]]; then
    XP_ARGS=("--" "${XP_ARGS[@]}")
  fi

  # If there is any options, escape them.
  if [[ ! -z "${XP_OPTIONS[*]-}" ]]; then
    _opts4args=$(xpns_arr2args "${XP_OPTIONS[@]}")
  fi
  _args4args=$(xpns_arr2args "${XP_ARGS[@]}")

  local wait_id="pre_execute-$$"

  # Create new session.
  ${TMUX_XPANES_EXEC} -S "${XP_SOCKET_PATH}" new-session -s "${XP_SESSION_NAME}" -n "${XP_TMP_WIN_NAME}" -d \
    "$(xpns_wait_func "${wait_id}")"$'\n'"${XP_ABS_THIS_FILE_NAME} ${_opts4args} ${_args4args}"

  # Suppress allow-rename for old tmux version
  local _def_allow_rename=
  _def_allow_rename="$(xpns_get_global_tmux_conf 'allow-rename' "${XP_SOCKET_PATH}")"
  xpns_suppress_allow_rename "${_def_allow_rename-}" "${XP_SOCKET_PATH}"

  xpns_notify "${wait_id}"
  xpns_delete_notify "${wait_id}"

  # Avoid attaching (for unit testing).
  if [[ ${XP_OPT_ATTACH} -eq 1 ]]; then
    if ! ${TMUX_XPANES_EXEC} -S "${XP_SOCKET_PATH}" attach-session -t "${XP_SESSION_NAME}" \
      && [[ ${XP_IS_PIPE_MODE} -eq 1 ]]; then
      xpns_msg "Recovery" \
"Execute below command line to re-attach the new session.

${TMUX_XPANES_EXEC} -S ${XP_SOCKET_PATH} attach-session -t ${XP_SESSION_NAME}

"
      # It might be failed. Before applying changes, first window might be closed.
      xpns_restore_allow_rename "${_def_allow_rename-}" "${XP_SOCKET_PATH}"
      exit ${XP_ETTY}
    fi
  fi
  # It might be failed. Before applying changes, first window might be closed.
  xpns_restore_allow_rename "${_def_allow_rename-}" "${XP_SOCKET_PATH}"
}

# Execute from inside of tmux session
xpns_execution() {
  local _pane_base_index=
  local _window_name=
  local _last_args_idx=
  local _def_allow_rename=
  local _pane_count=0
  local _is_pane_title_required=0

  if [[ ${XP_IS_PIPE_MODE} -eq 0 ]] && [[ -n "${XP_MAX_PANE_ARGS-}" ]];then
    xpns_set_args_per_pane "${XP_MAX_PANE_ARGS}"
  fi

  _pane_base_index=$(xpns_get_global_tmux_conf 'pane-base-index')
  _last_args_idx=$((${#XP_ARGS[@]} - 1))
  _def_allow_rename="$(xpns_get_global_tmux_conf 'allow-rename')"

  xpns_suppress_allow_rename "${_def_allow_rename-}"

  if [[ ${XP_OPT_EXTRA} -eq 1 ]];then
    # Reuse existing window name
    # tmux 1.6 does not support -F option
    _window_name="$( ${TMUX_XPANES_EXEC} display -p -F "#{window_id}" )"
    _pane_count="$( ${TMUX_XPANES_EXEC} list-panes | grep -c . )"
    _pane_base_index=$(( _pane_base_index + _pane_count - 1 ))
    _pane_active_pane_id=$(${TMUX_XPANES_EXEC} display -p -F "#{pane_id}")
  else
    _window_name=$(
      xpns_generate_window_name \
        "${XP_EMPTY_STR}" \
        "${XP_ARGS[0]}" \
        | xpns_value2key)
  fi

  ## --------------------
  # Prepare window and panes
  ## --------------------
  if [[ ${XP_OPT_EXTRA} -eq 1 ]];then
    xpns_extra_panes_to_window \
      "${_window_name}" \
      "${_pane_base_index}" \
      "${XP_OPT_LOG_STORE}" \
      "${XP_OPT_SET_TITLE}" \
      "${XP_OPT_SPEEDY}" \
      "${XP_OPT_SPEEDY_AWAIT}" \
      "${XP_REPSTR}" \
      "${XP_CMD_UTILITY}" \
      "${XP_ARGS[@]}"
  else
    xpns_prepare_window \
      "${_window_name}" \
      "${_pane_base_index}" \
      "${XP_OPT_LOG_STORE}" \
      "${XP_OPT_SET_TITLE}" \
      "${XP_OPT_ATTACH}" \
      "${XP_OPT_SPEEDY}" \
      "${XP_OPT_SPEEDY_AWAIT}" \
      "${XP_REPSTR}" \
      "${XP_CMD_UTILITY}" \
      "${XP_ARGS[@]}"
  fi

  ## With -ss option, it is possible to close all the panes as of here.
  ## Check status of the window. If no window exists, there is nothing to do execpt to exit.
  xpns_msg_debug "xpns_is_window_alive:1: After window separation"
  xpns_is_window_alive "${_window_name}" "${XP_OPT_SPEEDY_AWAIT}" "${_def_allow_rename-}"

  if [[ ${XP_OPT_EXTRA} -eq 1 ]];then
    # Set offset to avoid sending command to the original pane.
    _pane_base_index=$((_pane_base_index + 1))
    # Avoid to make layout even-horizontal even if there are many panes.
    # in xpns_arrange_pane_location
    _last_args_idx=$((_last_args_idx + _pane_count))
    # Re-select the windown that was active before.
    ${TMUX_XPANES_EXEC} select-pane -t "${_window_name}.${_pane_active_pane_id}"
  fi

  if [[ ${XP_OPT_LOG_STORE} -eq 1 ]]; then
    xpns_enable_logging \
      "${_window_name}" \
      "${_pane_base_index}" \
      "${TMUX_XPANES_LOG_DIRECTORY}" \
      "${TMUX_XPANES_LOG_FORMAT}" \
      "${XP_EMPTY_STR}" \
      "${XP_ARGS[@]}"

    if [[ $XP_OPT_SPEEDY -eq 1 ]]; then
      xpns_notify_logging \
        "${_window_name}" \
        "${XP_ARGS[@]}"
    fi
  fi

  xpns_msg_debug "xpns_is_window_alive:2: After logging"
  xpns_is_window_alive "${_window_name}" "${XP_OPT_SPEEDY_AWAIT}" "${_def_allow_rename-}"

  if xpns_is_pane_title_required "${XP_OPT_SET_TITLE}" "${XP_OPT_EXTRA}" ;then
    _is_pane_title_required=1
  fi

  # Set pane titles for each pane.
  if [[ $_is_pane_title_required -eq 1 ]];then
    xpns_set_titles \
      "${_window_name}" \
      "${_pane_base_index}" \
      "${XP_ARGS[@]}"
    if [[ $XP_OPT_SPEEDY -eq 1 ]];then
      xpns_notify_title \
        "${_window_name}" \
        "${XP_ARGS[@]}"
    fi
  fi

  xpns_msg_debug "xpns_is_window_alive:3: After setting title"
  xpns_is_window_alive "${_window_name}" "${XP_OPT_SPEEDY_AWAIT}" "${_def_allow_rename-}"

  ## Select pane by -f option
  if [[ -n "${XP_FOCUS_PANE_DSL}" ]]; then
    local _dsl_result
    if _dsl_result=$(xpns_DSL_execute "${XP_FOCUS_PANE_DSL}") ;then
      ${TMUX_XPANES_EXEC} select-pane -t "${_window_name}.$_dsl_result"
    else
      xpns_msg_warning "-f option is ignored."
    fi
  fi

  # Sending operations for each pane.
  # With -s option, command is already sent.
  if [[ $XP_OPT_SPEEDY -eq 0 ]]; then
    xpns_send_commands \
      "${_window_name}" \
      "${_pane_base_index}" \
      "${XP_REPSTR}" \
      "${XP_CMD_UTILITY}" \
      "${XP_ARGS[@]}"
  fi

  xpns_msg_debug "xpns_is_window_alive:4: After sending commands"
  xpns_is_window_alive "${_window_name}" "${XP_OPT_SPEEDY_AWAIT}" "${_def_allow_rename-}"

  if [[ $XP_OPT_SIZING -eq 0 ]] ;then
    xpns_arrange_pane_location \
      "${_window_name}" \
      "${_last_args_idx}"
  fi

  # Enable broadcasting
  if [[ ${XP_OPT_IS_SYNC} -eq 1 ]] && [[ ${XP_OPT_EXTRA} -eq 0 ]]; then
    ${TMUX_XPANES_EXEC} \
      set-window-option -t "${_window_name}" \
      synchronize-panes on
  fi

  ## In case of -t option
  if [[ ${XP_OPT_SET_TITLE} -eq 1 ]] && [[ ${XP_OPT_CHANGE_BORDER} -eq 1 ]]; then
    # Set border format
    ${TMUX_XPANES_EXEC} \
      set-window-option -t "${_window_name}" \
      pane-border-format "${TMUX_XPANES_PANE_BORDER_FORMAT}"
    # Show border status
    ${TMUX_XPANES_EXEC} \
      set-window-option -t "${_window_name}" \
      pane-border-status "${TMUX_XPANES_PANE_BORDER_STATUS}"
  fi

  # In case of -x, this statement is skipped to keep the original window name
  if [[ ${XP_OPT_EXTRA} -eq 0 ]];then
    # Restore original window name.
    ${TMUX_XPANES_EXEC} \
      rename-window -t "${_window_name}" \
      -- "$(printf "%s\\n" "${_window_name}" | xpns_key2value)"
  fi

  xpns_restore_allow_rename "${_def_allow_rename-}"
}

## --------------------------------
# Main function
## --------------------------------
xpns_main() {
  xpns_parse_options "${1+"$@"}"
  xpns_check_env "${XP_DEPENDENCIES}"
  ## --------------------------------
  # Parameter validation
  ## --------------------------------
  # When do dry-run flag is enabled, skip running (this is used to execute unit test of itself).
  if [[ ${XP_OPT_DRY_RUN} -eq 1 ]]; then
    return 0
  fi
  # Validate log directory.
  if [[ ${XP_OPT_LOG_STORE} -eq 1 ]]; then
    TMUX_XPANES_LOG_DIRECTORY=$(xpns_normalize_directory "${TMUX_XPANES_LOG_DIRECTORY}")
    xpns_is_valid_directory "${TMUX_XPANES_LOG_DIRECTORY}" && \
    TMUX_XPANES_LOG_DIRECTORY=$(cd "${TMUX_XPANES_LOG_DIRECTORY}" && pwd)
  fi
  ## --------------------------------
  # If current shell is outside of tmux session.
  ## --------------------------------
  if [[ -z "${TMUX-}" ]]; then
    xpns_pre_execution
  ## --------------------------------
  # If current shell is already inside of tmux session.
  ## --------------------------------
  else
    xpns_execution
  fi
  exit 0
}

## --------------------------------
# Entry Point
## --------------------------------
xpns_main "${1+"$@"}"
